name: Rust

on:
  push:
    branches: [ "master", "develop" ]
  pull_request:
    branches: [ "master", "develop" ]

env:
  CARGO_TERM_COLOR: always
  # Postgres-SQL Env Vars
  POSTGRES_DB: test_db
  POSTGRES_USER: runner
  POSTGRES_PASSWORD: password
  DATABASE_URL: postgresql://runner:password@localhost:5432/test_db

jobs:
  build_and_test:
    strategy:
      matrix:
        os: [ ubuntu-latest ] # Matrix with only ubuntu for now
      fail-fast: false # Optional: set to false if you want all matrix jobs to complete even if one fails

    runs-on: ${{ matrix.os }} # Use the OS from the matrix

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache Cargo registry and index
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable # Or your specific toolchain version
          profile: minimal

      # --- PostgresSQL Setup via apt (Ubuntu) ---
      - name: Install and Start Postgres SQL (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          echo "Setting up PostgreSQL on Ubuntu..."
          sudo apt-get update -y
          sudo apt-get install -y postgresql postgresql-contrib
          sudo systemctl start postgresql
          
          echo "Creating database and user..."
          # Create a user and grant superuser for CI simplicity
          sudo -u postgres createuser --superuser ${{ env.POSTGRES_USER }}
          # Set the password for the new user
          sudo -u postgres psql -c "ALTER USER ${{ env.POSTGRES_USER }} WITH PASSWORD '${{ env.POSTGRES_PASSWORD }}';"
          # Create the database owned by the new user
          sudo -u postgres createdb -O ${{ env.POSTGRES_USER }} ${{ env.POSTGRES_DB }}
          
          echo "Waiting for PostgreSQL to be ready..."
          timeout=60
          until pg_isready -h localhost -p 5432 -U "${{ env.POSTGRES_USER }}" -d "${{ env.POSTGRES_DB }}"; do
            timeout=$((timeout - 5))
            if [ $timeout -le 0 ]; then
              echo "PostgreSQL did not become ready in time."
              # Optional: Show logs
              sudo tail -n 50 /var/log/postgresql/postgresql-*-main.log
              exit 1
            fi
            sleep 5
          done
          echo "PostgreSQL is ready and accessible."

      # --- Cassandra Setup via apt (Ubuntu) ---
      - name: Install and Start Cassandra (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          echo "Installing dependencies for Cassandra..."
          # Install Java and other Cassandra dependencies
          sudo apt-get update -y
          sudo apt-get install -y apt-transport-https gnupg ca-certificates openjdk-11-jdk
          
          # Set JAVA_HOME for the rest of the job
          echo "JAVA_HOME=$(update-java-alternatives -l | head -n 1 | awk '{print $3}')" >> $GITHUB_ENV
          
          # 2. Add the Apache Cassandra repository GPG key
          sudo mkdir -p /etc/apt/keyrings
          curl -L https://debian.cassandra.apache.org/KEYS | sudo gpg --dearmor -o /etc/apt/keyrings/apache-cassandra.asc
          
          # 3. Add the Cassandra repository to a new sources list file
          # This is the correct format and URL from the official documentation
          echo "deb [signed-by=/etc/apt/keyrings/apache-cassandra.asc] https://debian.cassandra.apache.org 41x main" | sudo tee /etc/apt/sources.list.d/cassandra.list > /dev/null
          
          echo "Installing Cassandra..."
          sudo apt-get update -y
          sudo apt-get install -y cassandra
          
          echo "Starting Cassandra service..."
          sudo service cassandra start
          
          echo "Waiting for Cassandra to become fully operational..."
          timeout=240
          interval=15
          elapsed=0
          # Loop until nodetool status returns success
          while ! nodetool status > /dev/null 2>&1; do
            if [ $elapsed -ge $timeout ]; then
              echo "Cassandra did not become operational (nodetool status failed) within $timeout seconds."
              echo "Final nodetool status output:"
              nodetool status || echo "nodetool status command also failed to execute."
              echo "--- Cassandra system.log (last 50 lines) ---"
              sudo tail -n 50 /var/log/cassandra/system.log
              exit 1
            fi
            echo "Cassandra not up yet (nodetool status), waiting ($elapsed/$timeout s)..."
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Cassandra started successfully and nodetool status is OK."
          nodetool status

      # --- Cassandra C++ Driver Installation (Ubuntu) ---
      - name: Install Cassandra C++ Driver (macOS)
        if: runner.os == 'Linux'
        run: |
          echo "Installing Cassandra C++ Driver on Ubuntu..."
          # libgssapi-krb5-2 is a runtime dependency for the driver
          sudo apt-get install -y libuv1-dev libssl-dev cmake pkg-config libgssapi-krb5-2 libcassandra-cpp-driver-dev
          echo "Finished: Install Cassandra C++ Driver (Ubuntu)"

      #      # --- Set Environment Variables for Rust Build (macOS) ---
      #      - name: Set Build Environment Variables (macOS)
      #        if: runner.os == 'macOS'
      #        run: |
      #          echo "Setting macOS build environment variables..."
      #          OPENSSL_PREFIX=$(brew --prefix openssl)
      #
      #          # Prepend Homebrew paths and OpenSSL specific paths
      #          echo "LIBRARY_PATH=$(brew --prefix)/lib:$OPENSSL_PREFIX/lib${LIBRARY_PATH:+:$LIBRARY_PATH}" >> $GITHUB_ENV
      #          echo "CPATH=$(brew --prefix)/include:$OPENSSL_PREFIX/include${CPATH:+:$CPATH}" >> $GITHUB_ENV
      #
      #          echo "OPENSSL_ROOT_DIR=$OPENSSL_PREFIX" >> $GITHUB_ENV
      #          echo "OPENSSL_LIB_DIR=$OPENSSL_PREFIX/lib" >> $GITHUB_ENV
      #          echo "OPENSSL_INCLUDE_DIR=$OPENSSL_PREFIX/include" >> $GITHUB_ENV
      #          echo "*** macOS ENV Vars Set ***"

      # --- Run SQL Migrations ---
      - name: Run SQL Migrations (PostgresSQL)
        # This step assumes the migration tool uses the DATABASE_URL environment variable.
        # It also assumes the migration tool (e.g., sqlx-cli, diesel_cli) is available.
        # Example: If using sqlx-cli, and it's not installed globally, run:
        # cargo install sqlx-cli --no-default-features --features native-tls,postgres
        run: |
          echo "Running PostgresSQL migrations... Attempting to run migrations with sqlx-cli ..."
          if ! command -v sqlx &> /dev/null
          then
            echo "sqlx-cli not found, installing..."
            cargo install sqlx-cli --no-default-features --features native-tls,postgres
            # Verify installation
            if ! command -v sqlx &> /dev/null
            then
              echo "Failed to install sqlx-cli. Please ensure your migration tool is available."
              exit 1
            fi
          fi
          
          # Assumes the migrations are in root at './migrations' and The DATABASE_URL env variable is already set.
          sqlx migrate run --source ./migrations 
          
          echo "PostgresSQL migrations completed."
          # If you also have Cassandra schema setup/migrations, add those commands here.
          # Example: cqlsh -f ./path/to/cassandra_schema.cql || echo "Cassandra schema setup might have issues."

      # --- Build and Test ---
      - name: Build Project
        run: cargo build --verbose

      - name: Run tests
        run: cargo test --verbose
