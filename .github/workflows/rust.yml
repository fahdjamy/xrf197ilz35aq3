name: Rust

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

env:
  CARGO_TERM_COLOR: always
  # PostgreSQL Env Vars
  POSTGRES_USER: runner
  POSTGRES_PASSWORD: password
  POSTGRES_DB: test_db
  DATABASE_URL: postgresql://runner:password@localhost:5432/test_db

jobs:
  build_and_test:
    strategy:
      matrix:
        os: [ macos-latest ] # Matrix with only macOS for now
      fail-fast: false # Optional: set to false if you want all matrix jobs to complete even if one fails

    runs-on: ${{ matrix.os }} # Use the OS from the matrix

    # Service container for PostgreSQL
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Install and Start PostgresSQL via Homebrew (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "Setting up PostgreSQL on macOS using Homebrew..."
          brew install postgresql@15 # Or your desired PostgreSQL version
          brew services start postgresql@15
          
          echo "Waiting for Homebrew PostgreSQL to start..."
          # Add a robust wait loop for PostgreSQL to be ready
          timeout=120 # 2 minutes
          interval=5  # check every 5 seconds
          elapsed=0
          # Ensure pg_isready is in PATH. brew install postgresql usually adds it.
          # For DATABASE_URL: postgresql://runner:password@localhost:5432/test_db
          # pg_isready uses PGPASSWORD if set, or might try to connect without password
          # Ensure your postgresql setup allows connection for the 'runner' user or the default user.
          # For Homebrew, the default user is often your macOS username.
          # You might need to create the user/db if brew doesn't do it as per your env vars.
          # For simplicity, this health check just checks if the server is accepting connections.
          # You may need to run `createdb test_db` and `createuser --superuser runner` or similar
          # after brew services start postgresql if your tests require specific user/db.
          # The DATABASE_URL implies user 'runner' and db 'test_db'.
          # Create the database if it doesn't exist after starting
          psql -U postgres -c "CREATE DATABASE ${{ env.POSTGRES_DB }} ENCODING 'UTF8' TEMPLATE template0;" || echo "Database ${{ env.POSTGRES_DB }} may already exist or creation failed"
          psql -U postgres -c "CREATE USER ${{ env.POSTGRES_USER }} WITH PASSWORD '${{ env.POSTGRES_PASSWORD }}' SUPERUSER;" || echo "User ${{ env.POSTGRES_USER }} may already exist or creation failed"
          
          
          PG_ISREADY_CMD="pg_isready -h localhost -p 5432 -U ${{ env.POSTGRES_USER }} -d ${{ env.POSTGRES_DB }} -q"
          
          while ! $PG_ISREADY_CMD; do
            if [ $elapsed -ge $timeout ]; then
              echo "Homebrew PostgreSQL did not start or is not accessible with user/db within $timeout seconds."
              echo "Command used: $PG_ISREADY_CMD"
              exit 1
            fi
            echo "Homebrew PostgreSQL not up yet, waiting ($elapsed/$timeout s)..."
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Homebrew PostgreSQL started and accessible."

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache Cargo registry and index
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable # Or your specific toolchain version
          profile: minimal

      # --- PostgresSQL Client Setup (macOS) ---
      - name: Install PostgresSQL Client (macOS)
        if: runner.os == 'macOS' # Keep conditional for macOS-specific steps
        run: |
          brew install libpq
          # Add libpq binaries to PATH for Apple Silicon and Intel Macs
          if [ -d "/opt/homebrew/opt/libpq/bin" ]; then
            echo "/opt/homebrew/opt/libpq/bin" >> $GITHUB_PATH
          fi
          if [ -d "/usr/local/opt/libpq/bin" ]; then
            echo "/usr/local/opt/libpq/bin" >> $GITHUB_PATH
          fi

      # --- Cassandra Setup (macOS) ---
      - name: Install and Start Cassandra (macOS)
        if: runner.os == 'macOS' # Keep conditional for macOS-specific steps
        run: |
          echo "Installing Cassandra on macOS..."
          brew install cassandra
          
          # Attempt to configure JAVA_HOME if not set, as Cassandra needs it.
          # Homebrew often installs OpenJDK as a dependency.
          if [ -z "$JAVA_HOME" ]; then
            echo "JAVA_HOME not set. Attempting to find Homebrew OpenJDK..."
            # Common paths for Homebrew OpenJDK
            if [ -d "/opt/homebrew/opt/openjdk/libexec/openjdk.jdk/Contents/Home" ]; then # Apple Silicon
              export JAVA_HOME="/opt/homebrew/opt/openjdk/libexec/openjdk.jdk/Contents/Home"
            elif [ -d "/usr/local/opt/openjdk/libexec/openjdk.jdk/Contents/Home" ]; then # Intel
              export JAVA_HOME="/usr/local/opt/openjdk/libexec/openjdk.jdk/Contents/Home"
            elif [ -x "/usr/libexec/java_home" ]; then # macOS provided utility
               export JAVA_HOME=$(/usr/libexec/java_home)
            else
              echo "WARNING: Could not automatically determine JAVA_HOME. Cassandra might fail to start."
            fi
            if [ ! -z "$JAVA_HOME" ]; then
                echo "Setting JAVA_HOME to $JAVA_HOME"
                echo "JAVA_HOME=$JAVA_HOME" >> $GITHUB_ENV
            fi
          else
            echo "JAVA_HOME is already set to: $JAVA_HOME"
          fi
          
          echo "Starting Cassandra in the background..."
          cassandra -f &
          
          echo "Waiting for Cassandra to start..."
          timeout=240 # Increased timeout for Cassandra on macOS
          interval=15
          elapsed=0
          
          NODETOOL_PATH=""
          # Try to find nodetool, preferring brew's cassandra installation path
          if [ -x "$(brew --prefix cassandra)/bin/nodetool" ]; then
            NODETOOL_PATH="$(brew --prefix cassandra)/bin/nodetool"
          elif [ -x "/opt/homebrew/bin/nodetool" ]; then # Apple Silicon default for some tools
             NODETOOL_PATH="/opt/homebrew/bin/nodetool"
          elif [ -x "/usr/local/bin/nodetool" ]; then # Intel Macs default for some tools
             NODETOOL_PATH="/usr/local/bin/nodetool"
          else
            echo "nodetool not found in common brew paths! Attempting to use 'nodetool' directly."
            NODETOOL_PATH="nodetool" # Hope it's in PATH
          fi
          echo "Using nodetool path: $NODETOOL_PATH"
          
          while ! $NODETOOL_PATH status > /dev/null 2>&1; do
            if [ $elapsed -ge $timeout ]; then
              echo "Cassandra did not start within $timeout seconds."
              $NODETOOL_PATH status # Print status for debugging
              exit 1
            fi
            echo "Cassandra not up yet, waiting ($elapsed/$timeout s)..."
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Cassandra started successfully."
          $NODETOOL_PATH status

      # --- Cassandra C++ Driver Installation (macOS) ---
      - name: Install Cassandra C++ Driver (macOS)
        if: runner.os == 'macOS' # Keep conditional for macOS-specific steps
        run: |
          echo "Installing Cassandra C++ Driver on macOS..."
          # Ensure brew is updated, but don't fail the job if update itself has issues
          brew update || echo "Brew update potentially failed, attempting to continue..."
          # Install driver and its dependencies (cmake is often needed for build scripts)
          brew install cassandra-cpp-driver libuv openssl pkg-config cmake
          echo "Finished: Install Cassandra C++ Driver (macOS)"

      # --- Set Environment Variables for Rust Build (macOS) ---
      - name: Set Build Environment Variables (macOS)
        if: runner.os == 'macOS' # Keep conditional for macOS-specific steps
        run: |
          echo "Setting macOS build environment variables..."
          # Add Homebrew's lib and include paths for general libraries
          echo "LIBRARY_PATH=$(brew --prefix)/lib:$LIBRARY_PATH" >> $GITHUB_ENV
          echo "CPATH=$(brew --prefix)/include:$CPATH" >> $GITHUB_ENV
          
          # Specifically for OpenSSL, as Rust crates often look for these
          OPENSSL_PREFIX=$(brew --prefix openssl)
          echo "OPENSSL_ROOT_DIR=$OPENSSL_PREFIX" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=$OPENSSL_PREFIX/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=$OPENSSL_PREFIX/include" >> $GITHUB_ENV
          
          # Append OpenSSL paths to general LIBRARY_PATH and CPATH as well for broader compatibility
          # Note: Appending to existing $LIBRARY_PATH and $CPATH ensures we don't overwrite them if they were set by previous steps or system defaults.
          # However, for GITHUB_ENV, it's often better to construct the full desired path.
          # Let's ensure brew paths are prepended to give them priority.
          echo "LIBRARY_PATH=$(brew --prefix)/lib:$(brew --prefix openssl)/lib${LIBRARY_PATH:+:$LIBRARY_PATH}" >> $GITHUB_ENV
          echo "CPATH=$(brew --prefix)/include:$(brew --prefix openssl)/include${CPATH:+:$CPATH}" >> $GITHUB_ENV
          echo "*** macOS ENV Vars Set ***"

      # --- Debug Docker (Should not be needed if services block is working) ---
      - name: Check for Docker on macOS (Debug)
        if: runner.os == 'macOS' # Keep conditional for macOS-specific steps
        run: |
          echo "--- Checking for Docker (Debug Step) ---"
          echo "User: $(whoami)"
          echo "PATH: $PATH"
          which docker || echo "docker not found by 'which'"
          docker --version || echo "docker --version failed"
          echo "--- Docker Check Complete (Debug Step) ---"

      # --- Build and Test ---
      - name: Build Project
        run: cargo build --verbose

      - name: Run tests
        run: cargo test --verbose
