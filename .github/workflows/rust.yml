name: Rust

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

env:
  CARGO_TERM_COLOR: always
  # PostgresSQL Env Vars
  POSTGRES_DB: test_db
  POSTGRES_USER: runner
  POSTGRES_PASSWORD: password
  DATABASE_URL: postgresql://runner:password@localhost:5432/test_db

jobs:
  build_and_test:
    strategy:
      matrix:
        os: [ macos-latest ] # Matrix with only macOS for now
      fail-fast: false # Optional: set to false if you want all matrix jobs to complete even if one fails

    runs-on: ${{ matrix.os }} # Use the OS from the matrix

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache Cargo registry and index
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

      - name: Set up Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable # Or your specific toolchain version
          profile: minimal

      # --- PostgreSQL Setup via Homebrew (macOS) ---
      - name: Install and Start PostgresSQL (macOS via Homebrew)
        if: runner.os == 'macOS'
        run: |
          echo "Setting up PostgreSQL on macOS using Homebrew..."
          brew install postgresql@15 # Using PostgreSQL 15 as an example
          
          echo "Starting PostgreSQL service via Homebrew..."
          # This command also handles initdb if it's the first time.
          brew services start postgresql@15
          
          echo "Waiting for Homebrew PostgreSQL to initialize and start (increased wait)..."
          sleep 15 # Increased initial wait for initdb and service startup

          echo "Ensuring PostgreSQL client tools are on PATH..."
          PG_BIN_DIR=""
          # Check common Homebrew paths for PostgreSQL binaries
          if [ -d "/opt/homebrew/opt/postgresql@15/bin" ]; then # Apple Silicon
            PG_BIN_DIR="/opt/homebrew/opt/postgresql@15/bin"
          elif [ -d "/usr/local/opt/postgresql@15/bin" ]; then # Intel
            PG_BIN_DIR="/usr/local/opt/postgresql@15/bin"
          fi

          if [ ! -z "$PG_BIN_DIR" ] && [[ ":$PATH:" != *":$PG_BIN_DIR:"* ]]; then
            echo "Adding $PG_BIN_DIR to GITHUB_PATH and current PATH"
            echo "$PG_BIN_DIR" >> $GITHUB_PATH
            export PATH="$PG_BIN_DIR:$PATH" # Also for current script execution
          fi
          
          # Verify client tools are found
          which psql || (echo "ERROR: psql not found in PATH! Current PATH: $PATH" && exit 1)
          which createdb || (echo "ERROR: createdb not found in PATH!" && exit 1)
          which pg_isready || (echo "ERROR: pg_isready not found in PATH!" && exit 1)

          # The user running the script (runner on GitHub Actions) should be the default superuser
          # after Homebrew initializes the PostgreSQL cluster.
          PSQL_ADMIN_USER=$(whoami)
          DB_NAME="${{ env.POSTGRES_DB }}"
          APP_USER="${{ env.POSTGRES_USER }}"
          APP_PASSWORD="${{ env.POSTGRES_PASSWORD }}"

          echo "Attempting to create database '$DB_NAME' using admin user '$PSQL_ADMIN_USER'..."
          # Check if database exists first
          if psql -h localhost -p 5432 -U "$PSQL_ADMIN_USER" -lqt | cut -d \| -f 1 | grep -qw "$DB_NAME"; then
            echo "Database '$DB_NAME' already exists."
          else
            echo "Database '$DB_NAME' does not exist. Creating..."
            if ! createdb -h localhost -p 5432 -U "$PSQL_ADMIN_USER" "$DB_NAME"; then
              echo "ERROR: Failed to create database '$DB_NAME' with user '$PSQL_ADMIN_USER'."
              # Attempt to print PostgreSQL server logs for more clues
              echo "Attempting to print PostgreSQL logs..."
              if [ -d "$(brew --prefix)/var/log" ]; then cat $(brew --prefix)/var/log/postgres.log || echo "Could not cat main log."; fi
              if [ -d "$(brew --prefix)/var/postgresql@15" ]; then cat $(brew --prefix)/var/postgresql@15.log || echo "Could not cat versioned log."; fi
              exit 1
            fi
            echo "Database '$DB_NAME' created successfully."
          fi

          echo "Attempting to create or update user '$APP_USER' using admin user '$PSQL_ADMIN_USER'..."
          # Check if user exists
          if psql -h localhost -p 5432 -U "$PSQL_ADMIN_USER" -tc "SELECT 1 FROM pg_roles WHERE rolname = '$APP_USER'" | grep -q 1; then
            echo "User '$APP_USER' already exists. Altering password and ensuring SUPERUSER attribute (for CI simplicity)."
            if ! psql -h localhost -p 5432 -U "$PSQL_ADMIN_USER" -c "ALTER USER \"$APP_USER\" WITH PASSWORD '$APP_PASSWORD' SUPERUSER;"; then
              echo "ERROR: Failed to alter user '$APP_USER'."
              exit 1
            fi
            echo "User '$APP_USER' altered successfully."
          else
            echo "User '$APP_USER' does not exist. Creating with SUPERUSER attribute (for CI simplicity)..."
            if ! psql -h localhost -p 5432 -U "$PSQL_ADMIN_USER" -c "CREATE USER \"$APP_USER\" WITH LOGIN PASSWORD '$APP_PASSWORD' SUPERUSER;"; then
              echo "ERROR: Failed to create user '$APP_USER'."
              exit 1
            fi
            echo "User '$APP_USER' created successfully."
          fi
          
          # Grant all privileges on the specific database to the app user.
          # This is technically redundant if the APP_USER is a SUPERUSER, but good for clarity.
          echo "Granting ALL PRIVILEGES on database '$DB_NAME' to user '$APP_USER' (using admin '$PSQL_ADMIN_USER')..."
          if ! psql -h localhost -p 5432 -U "$PSQL_ADMIN_USER" -c "GRANT ALL PRIVILEGES ON DATABASE \"$DB_NAME\" TO \"$APP_USER\";"; then
              echo "ERROR: Failed to grant privileges to user '$APP_USER' on database '$DB_NAME'."
              # exit 1 # Not exiting here as superuser status might be sufficient
          else
              echo "Privileges granted successfully."
          fi

          echo "Verifying PostgreSQL readiness for user '$APP_USER' on database '$DB_NAME'..."
          timeout=120 # 2 minutes
          interval=5  # check every 5 seconds
          elapsed=0
          
          PG_ISREADY_CMD="pg_isready -h localhost -p 5432 -U \"$APP_USER\" -d \"$DB_NAME\" -q"
          
          while ! $PG_ISREADY_CMD; do
            if [ $elapsed -ge $timeout ]; then
              echo "Homebrew PostgreSQL did not become accessible with user '$APP_USER'/db '$DB_NAME' within $timeout seconds."
              echo "Command used for check: $PG_ISREADY_CMD"
              echo "PostgreSQL logs (if accessible via brew log path):"
              if [ -d "$(brew --prefix)/var/log" ]; then ls -la $(brew --prefix)/var/log; cat $(brew --prefix)/var/log/postgres.log || echo "Could not cat main log."; fi
              if [ -d "$(brew --prefix)/var/postgresql@15" ]; then cat $(brew --prefix)/var/postgresql@15.log || echo "Could not cat versioned log."; fi
              # Check general server status as admin
              echo "Checking general server status with admin user '$PSQL_ADMIN_USER':"
              pg_isready -h localhost -p 5432 -U "$PSQL_ADMIN_USER" -q || echo "Server also not ready for admin user '$PSQL_ADMIN_USER'."
              exit 1
            fi
            echo "Homebrew PostgreSQL not ready yet for $APP_USER@$DB_NAME (checking with: $PG_ISREADY_CMD), waiting ($elapsed/$timeout s)..."
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Homebrew PostgreSQL started and accessible with user '$APP_USER' on database '$DB_NAME'."

      # --- Cassandra Setup (macOS) ---
      - name: Install and Start Cassandra (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "Installing Cassandra on macOS..."
          brew install cassandra
          
          if [ -z "$JAVA_HOME" ]; then
            echo "JAVA_HOME not set. Attempting to find Homebrew OpenJDK..."
            if [ -d "/opt/homebrew/opt/openjdk/libexec/openjdk.jdk/Contents/Home" ]; then
              export JAVA_HOME="/opt/homebrew/opt/openjdk/libexec/openjdk.jdk/Contents/Home"
            elif [ -d "/usr/local/opt/openjdk/libexec/openjdk.jdk/Contents/Home" ]; then
              export JAVA_HOME="/usr/local/opt/openjdk/libexec/openjdk.jdk/Contents/Home"
            elif [ -x "/usr/libexec/java_home" ]; then
               export JAVA_HOME=$(/usr/libexec/java_home)
            else
              echo "WARNING: Could not automatically determine JAVA_HOME. Cassandra might fail to start."
            fi
            if [ ! -z "$JAVA_HOME" ]; then
                echo "Setting JAVA_HOME to $JAVA_HOME"
                echo "JAVA_HOME=$JAVA_HOME" >> $GITHUB_ENV
            fi
          else
            echo "JAVA_HOME is already set to: $JAVA_HOME"
          fi
          
          echo "Starting Cassandra in the background..."
          cassandra -f &
          
          echo "Waiting for Cassandra to start..."
          timeout=240
          interval=15
          elapsed=0
          
          NODETOOL_PATH=""
          if [ -x "$(brew --prefix cassandra)/bin/nodetool" ]; then
            NODETOOL_PATH="$(brew --prefix cassandra)/bin/nodetool"
          elif [ -x "/opt/homebrew/bin/nodetool" ]; then
             NODETOOL_PATH="/opt/homebrew/bin/nodetool"
          elif [ -x "/usr/local/bin/nodetool" ]; then
             NODETOOL_PATH="/usr/local/bin/nodetool"
          else
            echo "nodetool not found in common brew paths! Attempting 'nodetool' directly."
            NODETOOL_PATH="nodetool"
          fi
          echo "Using nodetool path: $NODETOOL_PATH"
          
          while ! $NODETOOL_PATH status > /dev/null 2>&1; do
            if [ $elapsed -ge $timeout ]; then
              echo "Cassandra did not start within $timeout seconds."
              $NODETOOL_PATH status
              exit 1
            fi
            echo "Cassandra not up yet, waiting ($elapsed/$timeout s)..."
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          echo "Cassandra started successfully."
          $NODETOOL_PATH status

      # --- Cassandra C++ Driver Installation (macOS) ---
      - name: Install Cassandra C++ Driver (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "Installing Cassandra C++ Driver on macOS..."
          brew update || echo "Brew update potentially failed, attempting to continue..."
          brew install cassandra-cpp-driver libuv openssl pkg-config cmake
          echo "Finished: Install Cassandra C++ Driver (macOS)"

      # --- Set Environment Variables for Rust Build (macOS) ---
      - name: Set Build Environment Variables (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "Setting macOS build environment variables..."
          OPENSSL_PREFIX=$(brew --prefix openssl)
          
          # Prepend Homebrew paths and OpenSSL specific paths
          echo "LIBRARY_PATH=$(brew --prefix)/lib:$OPENSSL_PREFIX/lib${LIBRARY_PATH:+:$LIBRARY_PATH}" >> $GITHUB_ENV
          echo "CPATH=$(brew --prefix)/include:$OPENSSL_PREFIX/include${CPATH:+:$CPATH}" >> $GITHUB_ENV
          
          echo "OPENSSL_ROOT_DIR=$OPENSSL_PREFIX" >> $GITHUB_ENV
          echo "OPENSSL_LIB_DIR=$OPENSSL_PREFIX/lib" >> $GITHUB_ENV
          echo "OPENSSL_INCLUDE_DIR=$OPENSSL_PREFIX/include" >> $GITHUB_ENV
          echo "*** macOS ENV Vars Set ***"
          echo "*** macOS ENV Vars Set ***"

      # --- Debug Docker (Should not be needed if services block is working) ---
      - name: Check for Docker on macOS (Debug)
        if: runner.os == 'macOS'
        run: |
          echo "--- Checking for Docker (Debug Step) ---"
          which docker || echo "docker not found by 'which'"
          docker --version || echo "docker --version failed"
          echo "--- Docker Check Complete (Debug Step) ---"

      # --- Build and Test ---
      - name: Build Project
        run: cargo build --verbose

      - name: Run tests
        run: cargo test --verbose
